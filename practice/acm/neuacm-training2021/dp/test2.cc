#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

int dp[10][3];
int DP(int x)
{
    bool isUnlucky = false; //初始设为false,初始状态是幸运的
    int s[15];
    int Index = 0, summ = x, unLuckyNum = 0;
    //为了适合人类习惯,反转数字,且从1开始数起
    for ( ; x; x /= 10 )
        s[++Index] = x % 10;
    s[Index + 1] = 0;

    for ( int i = Index; i > 0; --i ) //处理顺序从高到低
    {
        //如果本位是s[i],而且前一种状态存在倒霉数,则倒霉数会新增s[i]*dp[i][2] (1)
        //例如s[i][****4****],s[i][***62*****],s[i][***4****62***]这种情况,对应dp[i][2],

        unLuckyNum += (dp[i - 1][2] * s[i]);

        //分两个情况处理
        if ( isUnlucky )
            //case1:出现了倒霉数,4,62,这是上一轮产生的倒霉数,例如62[****],
            //(i指向2的下一位),或者4[******],(i指向4的下一位),与(1)区分开来
            //如果isUnlucky,实际上执行了两步,(1)处理历史遗留问题s[i][****4****],s[i][***62*****],
            //s[i][***4****62***],这里的[]属于dp[i][2],
            //(2)处理新产生的问题,例如:62[***]或4[****],这里的[]属于dp[i][0](低位可取任意值)
            //本位已经是倒霉数,低位是任意数它都会是倒霉数,所以,统计后面的所有情况即可
            //(不需再处理dp[i][2],上面已经处理过了),难点!类比进制转换就明白了
            unLuckyNum += (dp[i - 1][0] * s[i]);
        else {	//case2:不存在4或62(即只能在dp[i][0]和dp[i][1]中取)
            //>4的意思是必定途经4(是否途经6下一步再判断),例如5,则累计的时候需要
            //统计1,2,3,4,5．5种情况最高位取4,则后面任取,实际上,一个数"仅仅"大于4(类似5),
            //只执行了一步操作:unLuckyNum+=dp[i-1][0];
            if ( s[i] > 4 )
                unLuckyNum += dp[i - 1][0];
            //出现4和6,统计前一状态最高位是2的情况,则倒霉数出现的情况是本位为6,前一状态最高位是2
            //实际上,一个数如果>6,则它也>4,所以>6执行了这两步操作:unLuckyNum+=dp[i-1][0],(高位是4时)
            //unLuckyNum+=dp[i-1][1];(高位是6位时)
            if ( s[i] > 6 )
                unLuckyNum += dp[i - 1][1]; //处理本位是6的情况,本位是4的情况上面已经处理过了
            if ( s[i + 1] == 6 && s[i] > 2 )
                unLuckyNum += dp[i][1];//如果高位出现6,则取本位出现2的情况
        }
        if ( s[i] == 4 || s[i + 1] == 6 && s[i] == 2 ) //判断本位是否unlucky
            isUnlucky = true;
    }
    return summ - unLuckyNum;//所有的数减去倒霉数
}
int main()
{
    int a, b;
    memset(dp, 0, sizeof(dp));
    //预处理，算出所有可能
    dp[0][0] = 1;
    //dp[i][0],表示不存在4和62,最高位是不是2没有要求.
    //dp[i][1],表示不存在4和62,且最高位为2(dp[i][1]是dp[i][0]的一个子集
    //dp[i][2],表示存在4或62
    for ( int i = 1; i <= 8; ++i ) {
        //高位分别补除了4的9个数字，因为补了６，所以需要减去前一种最高位是2的情况
        dp[i][0] = dp[i - 1][0] * 9 - dp[i - 1][1];
        //在不含倒霉数的高位补2
        dp[i][1] = dp[i - 1][0];
        //各种出现4和62的情况,前一种情况已经出现了倒霉数，则高位有10种取法，
        //前边最高位是2,则高位取6,
        //前边没有倒霉数且最高位不是2,则高位取4
        dp[i][2] = dp[i - 1][2] * 10 + dp[i - 1][1] + dp[i - 1][0];
    }
    /*
    for(int i=0;i<10;++i)
    {
        for(int j=0;j<3;++j)
            cout<<dp[i][j]<<' ';
        cout<<endl;
    }
    */
    for ( ; scanf("%d%d", &a, &b);) {
        if ( a + b == 0 ) break;
        printf("%d\n", DP(b + 1) - DP(a));
    }
    return 0;
}